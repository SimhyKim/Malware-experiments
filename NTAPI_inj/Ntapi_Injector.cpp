#include <Windows.h>
#include <stdio.h>
#include "NTheader.h"
#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)
int main(int argc, char* argv[]) {

	NTSTATUS	status;
	DWORD       TID = NULL;
	DWORD       PID = NULL;
	LPVOID      rBuffer = NULL;
	HANDLE      hProcess = NULL;
	HANDLE      hThread = NULL;
	HMODULE		hNTDLL = NULL;
	HMODULE     hKernel32 = NULL;
	wchar_t     dllPath[MAX_PATH] = L"C:\\Users\\admin\\source\\repos\\newdll\\x64\\Debug\\newdll.dll";
	SIZE_T      pathSize = sizeof(dllPath);
	SIZE_T      bytesWritten = 0;

	if (argc < 2) {
		warn("usage: %s <PID>", argv[0]);
		return EXIT_FAILURE;
	}

	PID = atoi(argv[1]);
	/*hProcess = OpenProcess((PROCESS_VM_OPERATION | PROCESS_VM_WRITE), FALSE, PID);

	if (hProcess == NULL) {
		warn("unable to get a handle to the process (%ld), error: 0x%lx", PID, GetLastError());
		return EXIT_FAILURE;
	}*/

	OBJECT_ATTRIBUTES OA = { sizeof(OA), NULL };
	CLIENT_ID         CID = { (HANDLE)PID, NULL };

	hKernel32 = GetModuleHandleW(L"kernel32.dll");
	hNTDLL = GetModuleHandleW(L"ntdll.dll");

	if (hKernel32 == NULL || hNTDLL == NULL) {
		warn("failed to get a handle to Kernel32.dll, error: 0x%lx", GetLastError());
		return EXIT_FAILURE;
	}
	okay("got a handle to NTdll.dll");
	info("hNTDLL== 0x%p]\n", hNTDLL);
	okay("got a handle to Kernel32.dll");
	info("hKernel32== 0x%p]\n", hKernel32);
	/*поменять с поиска адреса на лоад либрари*/

	NtOpenProcess myOpenProcess = (NtOpenProcess)GetProcAddress(hNTDLL, "NtOpenProcess");
	okay("got NtOpenProcess!");

	status = myOpenProcess(&hProcess, PROCESS_ALL_ACCESS, &OA, &CID);
	if (status != STATUS_SUCCESS) {
		warn("failed to get a handle to the process, error: 0x%x", status);
		//goto CLEANUP;
	}

	okay("got a handle to the process: %ld", PID);
	info("hProcess == 0x%p]\n", hProcess);

	pNtCreateThreadEx myCreateThreadEx = (pNtCreateThreadEx)GetProcAddress(hNTDLL, "NtCreateThreadEx");
	info("address NtCreateThreadEx== 0x%p]\n", myCreateThreadEx);
	PTHREAD_START_ROUTINE myLoadLibrary = (PTHREAD_START_ROUTINE)GetProcAddress(hKernel32, "LoadLibraryW");
	info("address LoadLibraryW== 0x%p]\n", myLoadLibrary);

	/* Win32api рабочий вариант
	rBuffer = VirtualAllocEx(hProcess, rBuffer, pathSize, MEM_COMMIT, PAGE_READWRITE);
	printf("Buffer == %p\n", rBuffer);
	if (rBuffer == NULL) {
		warn("couldn't allocate a buffer to the target process memory, error: 0x%lx", GetLastError());
		
		//goto CLEANUP;
	}*/

	NtAllocateVirtualMemory myAllocateVirtualMemory = (NtAllocateVirtualMemory)GetProcAddress(hNTDLL, "NtAllocateVirtualMemory");
	okay("got NtWriteVirtualMemory!");

	status = myAllocateVirtualMemory(hProcess, &rBuffer, NULL, &pathSize, (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE);
	if (status != STATUS_SUCCESS) {
		warn("failed allocate buffer in process memory, error: 0x%x", status);
		//goto CLEANUP;
	}

	okay("allocated buffer in target process memory (PAGE_READWRITE)");

	/* Win32api рабочий вариант*/
	/*WriteProcessMemory(hProcess, rBuffer, dllPath, pathSize, &bytesWritten);
	okay("wrote %zu-bytes to the process memory", bytesWritten);*/
	
	NtWriteVirtualMemory myWriteVirtualMemory = (NtWriteVirtualMemory)GetProcAddress(hNTDLL, "NtWriteVirtualMemory");
	okay("got NtWriteVirtualMemory!");
	status = myWriteVirtualMemory(hProcess, rBuffer, dllPath, pathSize, &bytesWritten);
	if (status != STATUS_SUCCESS) {
		warn("failed to write to allocated buffer, error: 0x%x", status);
		goto CLEANUP;
	}

	status = myCreateThreadEx(&hThread, THREAD_ALL_ACCESS, &OA, hProcess, (PTHREAD_START_ROUTINE)myLoadLibrary, rBuffer, FALSE, NULL, NULL, NULL, NULL);

	if (status != STATUS_SUCCESS) {
		warn("failed to create thread, error: 0x%lx", status);
		goto CLEANUP;
	}
	//обычная функция создания треда работает
	/*hThread = CreateRemoteThread(hProcess, NULL, 0, myLoadLibrary, rBuffer, 0, &TID);
	if (hThread == NULL) {
		warn("unable to create thread, error: 0x%lx", GetLastError());
		goto CLEANUP;
	}*/
	okay("created a new thread in the target process! (%ld)", TID);
	info("hThread == 0x%p]\n", hThread);

	info("waiting for thread to finish");
	WaitForSingleObject(hThread, INFINITE);
	okay("thread finished execution");
	goto CLEANUP;

CLEANUP:

	if (hThread) {
		info("closing handle to thread");
		CloseHandle(hThread);
	}

	if (hProcess) {
		info("closing handle to process");
		CloseHandle(hProcess);
	}

	okay("finished cleaning");
	return EXIT_SUCCESS;

}